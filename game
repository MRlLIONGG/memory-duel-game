<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Emoji Memory & Duel Game - Made by Adam</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;600&display=swap');

    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0; padding: 0;
      background: linear-gradient(135deg, #f79d00, #64f38c);
      color: #222;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      flex-direction: column;
      padding: 30px 0;
      user-select: none;
      overflow-x: hidden;
      position: relative;
    }

    /* Background animation */
    @keyframes bgMove {
      0% {background-position: 0% 50%;}
      50% {background-position: 100% 50%;}
      100% {background-position: 0% 50%;}
    }
    body {
      background: linear-gradient(270deg, #f79d00, #64f38c, #ffba08, #64f38c);
      background-size: 800% 800%;
      animation: bgMove 20s ease infinite;
    }

    h1 {
      margin: 0 0 30px 0;
      font-weight: 900;
      font-size: 3rem;
      color: #fff;
      text-align: center;
      text-shadow: 0 0 15px rgba(0,0,0,0.5);
      user-select: none;
    }
    h2.subtitle {
      font-weight: 600;
      font-size: 1.3rem;
      color: #fff;
      text-align: center;
      margin: 5px 0 30px 0;
      user-select: none;
    }

    button {
      cursor: pointer;
      user-select: none;
    }

    /* CONTAINER */
    .container {
      width: 700px;
      max-width: 95vw;
      background: rgba(255,255,255,0.97);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      padding: 30px 40px;
      margin: auto;
      min-height: 700px;
      position: relative;
      overflow: hidden;
    }

    /* TABS */
    .tab-buttons {
      display: flex;
      margin-bottom: 30px;
      border-radius: 12px;
      overflow: hidden;
      background: #c3f6d5;
      box-shadow: 0 5px 20px #8deba0;
      user-select: none;
    }
    .tab-buttons button {
      flex: 1;
      padding: 14px 0;
      border: none;
      color: #222;
      font-weight: 700;
      font-size: 1.2rem;
      background: #a1e1b4;
      transition: background 0.3s ease;
      user-select: none;
    }
    .tab-buttons button.active, .tab-buttons button:hover {
      background: #52b788;
      color: #fff;
    }

    /* AUTH FORMS */
    form {
      display: flex;
      flex-direction: column;
      color: #222;
    }
    input[type="text"], input[type="password"] {
      padding: 14px;
      margin-bottom: 20px;
      border-radius: 12px;
      border: 2px solid #52b788;
      font-size: 1.1rem;
      outline: none;
      transition: border-color 0.3s ease;
      font-weight: 600;
    }
    input[type="text"]:focus, input[type="password"]:focus {
      border-color: #2a9d8f;
    }
    button.submit-btn {
      background: #2a9d8f;
      color: white;
      border: none;
      font-weight: 700;
      padding: 16px;
      border-radius: 15px;
      font-size: 1.3rem;
      transition: background 0.3s ease;
      user-select: none;
    }
    button.submit-btn:hover {
      background: #1e796d;
    }
    #error-msg, #error-msg-register {
      color: #f94144;
      font-weight: 700;
      margin-bottom: 10px;
      min-height: 20px;
      text-align: center;
    }

    /* GAME SECTIONS */
    #game-section {
      display: none;
      margin-top: 20px;
      width: 100%;
      min-height: 520px;
      position: relative;
    }
    #game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      user-select: none;
      flex-wrap: wrap;
      gap: 10px;
    }
    #player-info {
      font-weight: 700;
      font-size: 1.2rem;
      color: #264653;
      flex: 1 1 auto;
      min-width: 150px;
    }
    #stats {
      display: flex;
      gap: 15px;
      font-weight: 700;
      font-size: 1.1rem;
      color: #264653;
      user-select: none;
      flex: 1 1 auto;
      min-width: 150px;
      justify-content: flex-end;
    }
    #stats div {
      background: #52b788;
      padding: 8px 14px;
      border-radius: 15px;
      box-shadow: 0 5px 12px #40976d;
      min-width: 75px;
      text-align: center;
    }
    #timer {
      font-weight: 900;
      font-size: 1.25rem;
      color: #e76f51;
      user-select: none;
    }

    /* Memory Game Grid */
    #game {
      display: grid;
      gap: 12px;
      justify-content: center;
      margin-top: 10px;
      user-select: none;
    }
    .card {
      width: 85px;
      height: 85px;
      background: #52b788;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      cursor: pointer;
      color: #fff;
      box-shadow: 0 5px 20px #3b7a5a;
      transition: background 0.3s ease, transform 0.25s ease;
      user-select: none;
      user-drag: none;
      position: relative;
    }
    .card.matched {
      background: #264653;
      cursor: default;
      box-shadow: none;
      transform: scale(0.9);
    }
    .card:active:not(.matched) {
      transform: scale(0.95);
    }

    /* Reveal button */
    #reveal-btn {
      margin-top: 15px;
      padding: 14px 30px;
      font-weight: 700;
      font-size: 1.2rem;
      background: #f4a261;
      color: #222;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      transition: filter 0.3s ease;
      user-select: none;
    }
    #reveal-btn:disabled {
      filter: grayscale(80%);
      cursor: not-allowed;
    }

    /* Signout */
    #signout-btn {
      background: #e63946;
      padding: 10px 20px;
      font-weight: 700;
      font-size: 1rem;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      color: white;
      user-select: none;
      transition: background 0.3s ease;
      z-index: 1000;
    }
    #signout-btn:hover {
      background: #a52730;
    }

    /* Win overlay */
    #win-overlay {
      position: fixed;
      top: 0; left: 0; right:0; bottom:0;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-weight: 700;
      font-size: 2.5rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      user-select: none;
    }
    #win-overlay.show {
      opacity: 1;
      pointer-events: all;
    }
    #win-overlay .confetti {
      width: 150px;
      height: 150px;
      margin-bottom: 20px;
      animation: confetti-fall 2s ease-in-out infinite;
    }
    @keyframes confetti-fall {
      0% { transform: rotate(0deg) translateY(0) }
      50% { transform: rotate(15deg) translateY(15px) }
      100% { transform: rotate(0deg) translateY(0) }
    }
    #win-overlay button {
      margin-top: 30px;
      padding: 15px 40px;
      background: #52b788;
      border: none;
      border-radius: 30px;
      font-size: 1.4rem;
      font-weight: 700;
      cursor: pointer;
      color: white;
      transition: background 0.3s ease;
      user-select: none;
    }
    #win-overlay button:hover {
      background: #3b7a5a;
    }

    /* Leaderboard */
    #leaderboard-section {
      margin-top: 40px;
      background: rgba(82,183,136,0.3);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 10px 50px rgba(0,0,0,0.3);
      color: #2f2f2f;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      user-select: none;
    }
    #leaderboard-section h3 {
      margin-top: 0;
      font-weight: 700;
      text-align: center;
      color: #2f2f2f;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      color: #2f2f2f;
    }
    th, td {
      padding: 12px 10px;
      text-align: center;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      user-select: none;
    }
    th {
      background: #264653;
      color: #fff;
      font-weight: 700;
    }
    tr:nth-child(even) {
      background: rgba(255,255,255,0.4);
    }

    /* LEVEL MAP */
    #level-select {
      margin-top: 20px;
      height: 220px;
      width: 100%;
      overflow-x: auto;
      padding-bottom: 20px;
      user-select: none;
      -webkit-overflow-scrolling: touch;
      position: relative;
      border-radius: 15px;
      background: #e6f0e9;
      box-shadow: inset 0 0 15px #9dd1a6;
    }
    #map-path {
      position: relative;
      height: 100%;
      width: max-content;
      min-width: 600px;
      padding: 20px 40px;
      display: flex;
      gap: 40px;
      align-items: center;
      flex-wrap: nowrap;
      user-select: none;
    }
    .level-node {
      position: relative;
      width: 65px;
      height: 65px;
      border-radius: 50%;
      background: #81b29a;
      box-shadow: 0 6px 15px #5a8a7d;
      color: white;
      font-weight: 700;
      font-size: 1.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
      user-select: none;
      flex-shrink: 0;
      user-drag: none;
    }
    .level-node.completed {
      background: #2a9d8f;
      box-shadow: 0 6px 20px #1e796d;
      color: #fff;
      transform: scale(1.1);
    }
    .level-node.locked {
      background: #c4c4c4;
      box-shadow: none;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }
    .level-node.current {
      border: 4px solid #f4a261;
      box-shadow: 0 0 20px #f4a261;
      transform: scale(1.15);
    }
    .level-node:hover:not(.locked):not(.current) {
      background: #52b788;
      box-shadow: 0 8px 30px #3b7a5a;
      transform: scale(1.2);
    }
    /* Connecting lines */
    .map-line {
      position: absolute;
      height: 6px;
      background: #52b788;
      border-radius: 3px;
      top: 50%;
      transform: translateY(-50%);
      left: 0;
      right: 0;
      margin: auto;
      user-select: none;
      z-index: 1;
    }
    .map-line.locked {
      background: #c4c4c4;
    }

    /* Owner Panel */
    #owner-panel {
      margin-top: 35px;
      background: #fefefe;
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      user-select: none;
    }
    #owner-panel h3 {
      margin-top: 0;
      font-weight: 700;
      color: #1a1a1a;
    }
    #owner-panel button {
      margin-top: 10px;
      padding: 12px 30px;
      font-weight: 700;
      font-size: 1.1rem;
      border-radius: 15px;
      border: none;
      background: #e63946;
      color: white;
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
    }
    #owner-panel button:hover {
      background: #a52730;
    }
    #owner-userlist {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px;
      background: #f7f7f7;
    }
    #owner-userlist div.user-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 10px;
      margin-bottom: 6px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 5px #ccc;
      font-weight: 600;
      user-select: none;
    }
    #owner-userlist div.user-item span {
      color: #222;
    }
    #owner-userlist div.user-item button {
      background: #e63946;
      border: none;
      border-radius: 12px;
      padding: 4px 10px;
      color: white;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
    }
    #owner-userlist div.user-item button:hover {
      background: #a52730;
    }

    /* Duel UI */
    #duel-section {
      display: none;
      margin-top: 20px;
      width: 100%;
      min-height: 520px;
      user-select: none;
      position: relative;
      color: #264653;
    }
    #duel-waiting {
      font-size: 1.4rem;
      font-weight: 700;
      text-align: center;
      margin-top: 100px;
      color: #2a9d8f;
    }
    #duel-game {
      display: none;
      margin-top: 30px;
      text-align: center;
    }
    #duel-info {
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: 20px;
    }
    #duel-cards {
      display: grid;
      grid-template-columns: repeat(4, 90px);
      gap: 15px;
      justify-content: center;
    }
    .duel-card {
      width: 90px;
      height: 90px;
      background: #52b788;
      border-radius: 18px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3rem;
      cursor: pointer;
      color: white;
      box-shadow: 0 5px 20px #3b7a5a;
      transition: background 0.3s ease, transform 0.25s ease;
      user-select: none;
      position: relative;
      user-drag: none;
    }
    .duel-card.revealed {
      background: #264653;
      cursor: default;
      transform: scale(1.1);
    }
    .duel-card:active:not(.revealed) {
      transform: scale(0.95);
    }
    #duel-result {
      margin-top: 30px;
      font-weight: 700;
      font-size: 1.5rem;
      color: #f4a261;
    }

  </style>
</head>
<body>

  <h1>Emoji Memory & Duel Game</h1>
  <h2 class="subtitle">Made by Adam Baydoun</h2>

  <div class="container">

    <div id="auth-section">
      <!-- Login Form -->
      <form id="login-form">
        <h2>Login</h2>
        <div id="error-msg"></div>
        <input type="text" id="login-username" placeholder="Username" autocomplete="off" required />
        <input type="password" id="login-password" placeholder="Password" autocomplete="off" required />
        <button type="submit" class="submit-btn">Login</button>
      </form>

      <!-- Register Form -->
      <form id="register-form" style="margin-top: 30px;">
        <h2>Register</h2>
        <div id="error-msg-register"></div>
        <input type="text" id="register-username" placeholder="Choose username" autocomplete="off" required />
        <input type="password" id="register-password" placeholder="Choose password" autocomplete="off" required />
        <button type="submit" class="submit-btn">Register</button>
      </form>
    </div>

    <button id="signout-btn" style="display:none;">Sign Out</button>

    <!-- TABS for Memory Game and Duel -->
    <div class="tab-buttons" style="display:none;">
      <button id="tab-memory" class="active">Memory Game</button>
      <button id="tab-duel">Duel</button>
    </div>

    <!-- GAME SECTION -->
    <div id="game-section">

      <!-- MEMORY GAME -->
      <div id="memory-section">
        <div id="game-header">
          <div id="player-info">Player: <span id="player-name"></span></div>
          <div id="stats">
            <div>Wins: <span id="wins-count">0</span></div>
            <div>Coins: <span id="coins-count">0</span></div>
          </div>
          <div id="timer">Time: 0.0s</div>
        </div>

        <div id="game"></div>

        <button id="reveal-btn" disabled>Reveal Cards</button>

        <div id="level-select">
          <div id="map-path"></div>
        </div>
      </div>

      <!-- DUEL -->
      <div id="duel-section">
        <div id="duel-waiting">Waiting for an opponent to join the duel queue...</div>

        <div id="duel-game">
          <div id="duel-info">Duel vs <span id="duel-opponent-name"></span> | Time: <span id="duel-timer">0.0</span>s</div>
          <div id="duel-cards"></div>
          <div id="duel-result"></div>
        </div>
      </div>

    </div>

    <!-- LEADERBOARD -->
    <div id="leaderboard-section" style="display:none;">
      <h3>Leaderboard</h3>
      <table>
        <thead>
          <tr><th>Rank</th><th>Player</th><th>Wins</th><th>Coins</th></tr>
        </thead>
        <tbody id="leaderboard-body"></tbody>
      </table>
    </div>

    <!-- OWNER PANEL -->
    <div id="owner-panel" style="display:none;">
      <h3>Owner Panel</h3>
      <button id="owner-refresh-users">Refresh User List</button>
      <div id="owner-userlist"></div>
    </div>

  </div>

  <div id="win-overlay">
    <svg class="confetti" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none"><circle cx="50" cy="50" r="50" fill="#f4a261"/></svg>
    <div id="win-message">You Win!</div>
    <button id="win-close-btn">Close</button>
  </div>

<script>
(() => {
  // Utility functions
  function saveUserData(user) {
    localStorage.setItem('user_' + user.username.toLowerCase(), JSON.stringify(user));
  }
  function loadUserData(username) {
    let data = localStorage.getItem('user_' + username.toLowerCase());
    if (!data) return null;
    return JSON.parse(data);
  }
  function deleteUserData(username) {
    localStorage.removeItem('user_' + username.toLowerCase());
  }
  function getAllUsers() {
    let users = [];
    for(let i=0; i < localStorage.length; i++) {
      let key = localStorage.key(i);
      if (key.startsWith('user_')) {
        let user = JSON.parse(localStorage.getItem(key));
        users.push(user);
      }
    }
    return users;
  }
  function formatTime(seconds) {
    return seconds.toFixed(1);
  }

  // ===== GLOBAL STATE =====
  let currentUser = null;
  let currentLevel = 1;
  let gameStarted = false;
  let firstCard = null;
  let secondCard = null;
  let matchedPairs = 0;
  let startTime = 0;
  let timerInterval = null;
  let revealUsed = false;

  // Duel state
  let duelQueue = [];
  let duelGameActive = false;
  let duelPlayer = null;
  let duelOpponent = null;
  let duelStartTime = 0;
  let duelTimerInterval = null;
  let duelMatchedPairs = 0;
  let duelFirstCard = null;
  let duelSecondCard = null;
  let duelRevealCount = 0;

  // Cards pool for memory and duel (same emoji set)
  const EMOJIS = ['ðŸµ', 'ðŸ¶', 'ðŸ±', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¯', 'ðŸ¸', 'ðŸ¥'];

  // Constants for reveal cards based on level difficulty (1,2,3,4)
  // Easy=1, Medium=2, Hard=3, Extreme=4
  function getRevealCountByLevel(level) {
    if (level <= 2) return 1;
    else if (level <= 4) return 2;
    else if (level <= 6) return 3;
    else return 4;
  }

  // DOM elements
  const loginForm = document.getElementById('login-form');
  const registerForm = document.getElementById('register-form');
  const errorMsg = document.getElementById('error-msg');
  const errorMsgRegister = document.getElementById('error-msg-register');
  const authSection = document.getElementById('auth-section');
  const signoutBtn = document.getElementById('signout-btn');

  const tabButtonsContainer = document.querySelector('.tab-buttons');
  const tabMemoryBtn = document.getElementById('tab-memory');
  const tabDuelBtn = document.getElementById('tab-duel');

  const gameSection = document.getElementById('game-section');
  const memorySection = document.getElementById('memory-section');
  const duelSection = document.getElementById('duel-section');

  const playerNameDisplay = document.getElementById('player-name');
  const winsCountDisplay = document.getElementById('wins-count');
  const coinsCountDisplay = document.getElementById('coins-count');
  const timerDisplay = document.getElementById('timer');
  const gameGrid = document.getElementById('game');
  const revealBtn = document.getElementById('reveal-btn');

  const mapPath = document.getElementById('map-path');

  const leaderboardSection = document.getElementById('leaderboard-section');
  const leaderboardBody = document.getElementById('leaderboard-body');

  const ownerPanel = document.getElementById('owner-panel');
  const ownerUserList = document.getElementById('owner-userlist');
  const ownerRefreshBtn = document.getElementById('owner-refresh-users');

  const winOverlay = document.getElementById('win-overlay');
  const winMessage = document.getElementById('win-message');
  const winCloseBtn = document.getElementById('win-close-btn');

  // Duel DOM elements
  const duelWaitingMsg = document.getElementById('duel-waiting');
  const duelGameDiv = document.getElementById('duel-game');
  const duelOpponentNameSpan = document.getElementById('duel-opponent-name');
  const duelTimerDisplay = document.getElementById('duel-timer');
  const duelCardsGrid = document.getElementById('duel-cards');
  const duelResultDisplay = document.getElementById('duel-result');

  // =========== AUTH ===========
  loginForm.addEventListener('submit', e => {
    e.preventDefault();
    errorMsg.textContent = '';
    const username = loginForm['login-username'].value.trim();
    const password = loginForm['login-password'].value;
    if (username.toLowerCase() === 'owner') {
      if (password === 'ownerpass') {
        currentUser = {
          username: 'Owner',
          password: 'ownerpass',
          wins: 0,
          coins: 0,
          completedLevels: [],
          isOwner: true,
        };
        loginSuccess();
        return;
      } else {
        errorMsg.textContent = 'Wrong username or password.';
        return;
      }
    }
    const userData = loadUserData(username);
    if (!userData) {
      errorMsg.textContent = 'User does not exist.';
      return;
    }
    if (userData.password !== password) {
      errorMsg.textContent = 'Wrong username or password.';
      return;
    }
    currentUser = userData;
    loginSuccess();
  });

  registerForm.addEventListener('submit', e => {
    e.preventDefault();
    errorMsgRegister.textContent = '';
    let username = registerForm['register-username'].value.trim();
    let password = registerForm['register-password'].value;
    if (username.toLowerCase() === 'owner') {
      errorMsgRegister.textContent = "Username 'Owner' is reserved.";
      return;
    }
    if (loadUserData(username)) {
      errorMsgRegister.textContent = 'Username already taken.';
      return;
    }
    if (username.length < 3) {
      errorMsgRegister.textContent = 'Username too short (min 3).';
      return;
    }
    if (password.length < 3) {
      errorMsgRegister.textContent = 'Password too short (min 3).';
      return;
    }
    currentUser = {
      username: username,
      password: password,
      wins: 0,
      coins: 0,
      completedLevels: [],
      isOwner: false,
    };
    saveUserData(currentUser);
    loginSuccess();
  });

  function loginSuccess() {
    authSection.style.display = 'none';
    signoutBtn.style.display = 'inline-block';
    tabButtonsContainer.style.display = 'flex';
    gameSection.style.display = 'block';
    leaderboardSection.style.display = 'block';

    playerNameDisplay.textContent = currentUser.username;
    winsCountDisplay.textContent = currentUser.wins || 0;
    coinsCountDisplay.textContent = currentUser.coins || 0;

    if (currentUser.isOwner) {
      ownerPanel.style.display = 'block';
      refreshOwnerUserList();
    } else {
      ownerPanel.style.display = 'none';
    }

    loadLevelMap();
    startMemoryGame();

    // Default to Memory tab active
    showMemoryTab();
  }

  signoutBtn.addEventListener('click', () => {
    location.reload();
  });

  // =========== LEVEL MAP ===========
  function loadLevelMap() {
    mapPath.innerHTML = '';
    const totalLevels = 8; // fixed 8 levels for demo

    for (let i = 1; i <= totalLevels; i++) {
      const node = document.createElement('div');
      node.classList.add('level-node');

      // Determine state
      if (currentUser.completedLevels && currentUser.completedLevels.includes(i)) {
        node.classList.add('completed');
      } else if (i === currentLevel) {
        node.classList.add('current');
      } else if (i > currentLevel) {
        node.classList.add('locked');
      }

      node.textContent = i;

      if (!node.classList.contains('locked')) {
        node.style.cursor = 'pointer';
        node.title = 'Play level ' + i;
        node.addEventListener('click', () => {
          if (!node.classList.contains('locked')) {
            currentLevel = i;
            resetMemoryGame();
          }
        });
      }

      mapPath.appendChild(node);

      // Add connecting line except last node
      if (i < totalLevels) {
        const line = document.createElement('div');
        line.classList.add('map-line');
        if (i >= currentLevel) line.classList.add('locked');
        line.style.width = '40px';
        mapPath.appendChild(line);
      }
    }
  }

  // =========== MEMORY GAME ===========
  function startMemoryGame() {
    gameGrid.style.gridTemplateColumns = 'repeat(4, 1fr)';
    revealBtn.disabled = false;
    revealUsed = false;
    matchedPairs = 0;
    firstCard = null;
    secondCard = null;
    gameStarted = false;
    timerDisplay.textContent = 'Time: 0.0s';
    gameGrid.innerHTML = '';

    // Prepare cards (pairs)
    let cardsNeeded = 8; // 8 pairs for 4x4 grid
    let emojiPairs = EMOJIS.slice(0, cardsNeeded);
    let cardsArray = [];

    emojiPairs.forEach(e => {
      cardsArray.push({emoji: e, matched: false});
      cardsArray.push({emoji: e, matched: false});
    });

    // Shuffle cards
    cardsArray = shuffle(cardsArray);

    // Create cards in DOM
    cardsArray.forEach((card, idx) => {
      let cardEl = document.createElement('div');
      cardEl.classList.add('card');
      cardEl.dataset.emoji = card.emoji;
      cardEl.dataset.index = idx;
      cardEl.textContent = ''; // Hidden initially

      cardEl.addEventListener('click', () => {
        if (gameStarted === false) {
          startTimer();
          gameStarted = true;
        }
        if (firstCard && secondCard) return;
        if (cardEl.classList.contains('matched')) return;
        if (cardEl === firstCard) return;

        revealCard(cardEl);
      });

      gameGrid.appendChild(cardEl);
    });

    // Reveal cards on start based on level difficulty for 1.5s with animation
    revealStartCards(getRevealCountByLevel(currentLevel));
  }

  function resetMemoryGame() {
    stopTimer();
    startMemoryGame();
    loadLevelMap();
  }

  function revealCard(cardEl) {
    cardEl.textContent = cardEl.dataset.emoji;
    cardEl.style.backgroundColor = '#264653';
    cardEl.style.color = '#fff';
    cardEl.style.transform = 'scale(1.1)';
    if (!firstCard) {
      firstCard = cardEl;
      return;
    }
    if (!secondCard) {
      secondCard = cardEl;
      // Check match after short delay
      setTimeout(checkMatch, 700);
    }
  }

  function checkMatch() {
    if (!firstCard || !secondCard) return;

    if (firstCard.dataset.emoji === secondCard.dataset.emoji) {
      // Matched
      firstCard.classList.add('matched');
      secondCard.classList.add('matched');
      matchedPairs++;
      // Mark cards as matched visually
      firstCard.style.backgroundColor = '#2a9d8f';
      secondCard.style.backgroundColor = '#2a9d8f';
      firstCard.style.color = '#fff';
      secondCard.style.color = '#fff';

      // Clear selection
      firstCard = null;
      secondCard = null;

      // Check if all pairs matched
      if (matchedPairs === 8) {
        onGameWin();
      }
    } else {
      // No match - hide cards
      firstCard.style.backgroundColor = '#52b788';
      firstCard.textContent = '';
      secondCard.style.backgroundColor = '#52b788';
      secondCard.textContent = '';
      firstCard.style.transform = '';
      secondCard.style.transform = '';

      firstCard = null;
      secondCard = null;
    }
  }

  // Reveal all cards at start for n seconds, then hide them again
  function revealStartCards(count) {
    if (count <= 0) return;
    let revealed = 0;
    let cards = Array.from(gameGrid.children);
    // Reveal 'count' cards at random for 1.5 seconds with animation
    let toReveal = shuffle(cards).slice(0, count * 2); // pairs = 2 cards per reveal count
    toReveal.forEach(card => {
      card.textContent = card.dataset.emoji;
      card.style.backgroundColor = '#264653';
      card.style.color = '#fff';
      card.style.transform = 'scale(1.1)';
    });
    revealBtn.disabled = true;

    setTimeout(() => {
      toReveal.forEach(card => {
        if (!card.classList.contains('matched')) {
          card.textContent = '';
          card.style.backgroundColor = '#52b788';
          card.style.transform = '';
        }
      });
      revealBtn.disabled = false;
    }, 1500);
  }

  revealBtn.addEventListener('click', () => {
    if (revealUsed) return;
    revealUsed = true;
    revealBtn.disabled = true;
    revealStartCards(getRevealCountByLevel(currentLevel));
  });

  function onGameWin() {
    stopTimer();
    gameStarted = false;
    currentUser.wins++;
    currentUser.coins += currentLevel * 10;
    if (!currentUser.completedLevels.includes(currentLevel)) {
      currentUser.completedLevels.push(currentLevel);
    }
    saveUserData(currentUser);
    winsCountDisplay.textContent = currentUser.wins;
    coinsCountDisplay.textContent = currentUser.coins;
    loadLevelMap();
    updateLeaderboard();

    winMessage.textContent = `You Win! Time: ${formatTime((Date.now() - startTime) / 1000)}s`;
    winOverlay.classList.add('show');
  }

  winCloseBtn.addEventListener('click', () => {
    winOverlay.classList.remove('show');
    resetMemoryGame();
  });

  // Timer
  function startTimer() {
    startTime = Date.now();
    timerDisplay.textContent = 'Time: 0.0s';
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      let elapsed = (Date.now() - startTime) / 1000;
      timerDisplay.textContent = 'Time: ' + formatTime(elapsed) + 's';
    }, 100);
  }
  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
  }

  // =========== OWNER PANEL ===========
  function refreshOwnerUserList() {
    ownerUserList.innerHTML = '';
    const users = getAllUsers();
    if (users.length === 0) {
      ownerUserList.textContent = 'No registered users.';
      return;
    }
    users.forEach(user => {
      let userDiv = document.createElement('div');
      userDiv.classList.add('user-item');
      userDiv.innerHTML = `<span>${user.username}</span> <button data-username="${user.username}">Delete</button>`;
      ownerUserList.appendChild(userDiv);

      userDiv.querySelector('button').addEventListener('click', e => {
        if (confirm(`Delete user ${user.username}? This cannot be undone.`)) {
          deleteUserData(user.username);
          refreshOwnerUserList();
          if (currentUser && currentUser.username.toLowerCase() === user.username.toLowerCase()) {
            alert('You deleted your own account. Signing out...');
            location.reload();
          }
        }
      });
    });
  }
  ownerRefreshBtn.addEventListener('click', refreshOwnerUserList);

  // =========== LEADERBOARD ===========
  function updateLeaderboard() {
    let users = getAllUsers();
    users = users.sort((a,b) => b.wins - a.wins || b.coins - a.coins);
    leaderboardBody.innerHTML = '';
    users.forEach((u, idx) => {
      let tr = document.createElement('tr');
      tr.innerHTML = `<td>${idx+1}</td><td>${u.username}</td><td>${u.wins || 0}</td><td>${u.coins || 0}</td>`;
      leaderboardBody.appendChild(tr);
    });
  }

  // Shuffle function
  function shuffle(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
  }

  // =========== TAB SWITCHING ===========
  tabMemoryBtn.addEventListener('click', () => {
    showMemoryTab();
  });
  tabDuelBtn.addEventListener('click', () => {
    showDuelTab();
  });

  function showMemoryTab() {
    tabMemoryBtn.classList.add('active');
    tabDuelBtn.classList.remove('active');
    memorySection.style.display = 'block';
    duelSection.style.display = 'none';
  }
  function showDuelTab() {
    tabMemoryBtn.classList.remove('active');
    tabDuelBtn.classList.add('active');
    memorySection.style.display = 'none';
    duelSection.style.display = 'block';
    startDuelQueue();
  }

  // =========== DUEL GAME ===========

  // Simple duel queue: when 2 players join duel queue, start duel game for both
  // Since single browser demo, simulate 2 players by user and a bot opponent

  function startDuelQueue() {
    if (duelGameActive) return; // already in duel game
    duelWaitingMsg.style.display = 'block';
    duelGameDiv.style.display = 'none';
    duelResultDisplay.textContent = '';
    duelTimerDisplay.textContent = '0.0';
    duelOpponentNameSpan.textContent = '';
    duelMatchedPairs = 0;
    duelFirstCard = null;
    duelSecondCard = null;
    duelRevealCount = 0;

    // Add current user to queue (in a real multiplayer you'd add players from server)
    if (!duelQueue.includes(currentUser.username)) {
      duelQueue.push(currentUser.username);
    }

    // If no opponent, simulate bot join after short delay
    if (duelQueue.length < 2) {
      setTimeout(() => {
        if (!duelQueue.includes('BotOpponent')) duelQueue.push('BotOpponent');
        checkDuelStart();
      }, 1000);
    } else {
      checkDuelStart();
    }
  }

  function checkDuelStart() {
    if (duelQueue.length >= 2) {
      // Start duel
      let p1 = duelQueue.shift();
      let p2 = duelQueue.shift();
      if (p1 === currentUser.username) {
        duelPlayer = currentUser;
        duelOpponent = (p2 === 'BotOpponent') ? {username: 'BotOpponent', isBot:true} : loadUserData(p2);
      } else if (p2 === currentUser.username) {
        duelPlayer = currentUser;
        duelOpponent = (p1 === 'BotOpponent') ? {username: 'BotOpponent', isBot:true} : loadUserData(p1);
      } else {
        // Not this user's duel, reset queue for demo
        duelPlayer = currentUser;
        duelOpponent = {username: 'BotOpponent', isBot:true};
      }
      startDuelGame();
    }
  }

  function startDuelGame() {
    duelGameActive = true;
    duelWaitingMsg.style.display = 'none';
    duelGameDiv.style.display = 'block';
    duelOpponentNameSpan.textContent = duelOpponent.username;
    duelMatchedPairs = 0;
    duelFirstCard = null;
    duelSecondCard = null;
    duelRevealCount = 0;
    duelResultDisplay.textContent = '';

    // Setup duel cards grid 4x4 with 8 pairs
    duelCardsGrid.innerHTML = '';
    let cardsNeeded = 8;
    let emojiPairs = EMOJIS.slice(0, cardsNeeded);
    let cardsArray = [];
    emojiPairs.forEach(e => {
      cardsArray.push({emoji: e, matched: false});
      cardsArray.push({emoji: e, matched: false});
    });
    cardsArray = shuffle(cardsArray);

    cardsArray.forEach((card, idx) => {
      let cardEl = document.createElement('div');
      cardEl.classList.add('duel-card');
      cardEl.dataset.emoji = card.emoji;
      cardEl.dataset.index = idx;
      cardEl.textContent = ''; // hidden initially

      cardEl.addEventListener('click', () => {
        if (duelMatchedPairs >= 8) return;
        if (cardEl.classList.contains('revealed')) return;
        if (duelFirstCard && duelSecondCard) return;
        if (cardEl === duelFirstCard) return;

        revealDuelCard(cardEl);
      });

      duelCardsGrid.appendChild(cardEl);
    });

    // Reveal cards briefly on start: reveal count depends on difficulty (level)
    revealDuelStartCards(getRevealCountByLevel(currentLevel));

    startDuelTimer();
  }

  function revealDuelCard(cardEl) {
    cardEl.textContent = cardEl.dataset.emoji;
    cardEl.style.backgroundColor = '#264653';
    cardEl.style.color = '#fff';
    cardEl.style.transform = 'scale(1.1)';
    if (!duelFirstCard) {
      duelFirstCard = cardEl;
      return;
    }
    if (!duelSecondCard) {
      duelSecondCard = cardEl;
      setTimeout(duelCheckMatch, 700);
    }
  }

  function duelCheckMatch() {
    if (!duelFirstCard || !duelSecondCard) return;

    if (duelFirstCard.dataset.emoji === duelSecondCard.dataset.emoji) {
      duelFirstCard.classList.add('revealed');
      duelSecondCard.classList.add('revealed');
      duelMatchedPairs++;

      duelFirstCard.style.backgroundColor = '#2a9d8f';
      duelSecondCard.style.backgroundColor = '#2a9d8f';

      duelFirstCard = null;
      duelSecondCard = null;

      if (duelMatchedPairs === 8) {
        endDuelGame(true);
      }
    } else {
      duelFirstCard.style.backgroundColor = '#52b788';
      duelFirstCard.textContent = '';
      duelSecondCard.style.backgroundColor = '#52b788';
      duelSecondCard.textContent = '';

      duelFirstCard.style.transform = '';
      duelSecondCard.style.transform = '';

      duelFirstCard = null;
      duelSecondCard = null;
    }
  }

  function revealDuelStartCards(count) {
    if (count <= 0) return;
    let cards = Array.from(duelCardsGrid.children);
    let toReveal = shuffle(cards).slice(0, count * 2);
    toReveal.forEach(card => {
      card.textContent = card.dataset.emoji;
      card.style.backgroundColor = '#264653';
      card.style.color = '#fff';
      card.style.transform = 'scale(1.1)';
    });
    // Disable clicking while revealed
    duelCardsGrid.style.pointerEvents = 'none';

    setTimeout(() => {
      toReveal.forEach(card => {
        if (!card.classList.contains('revealed')) {
          card.textContent = '';
          card.style.backgroundColor = '#52b788';
          card.style.transform = '';
        }
      });
      duelCardsGrid.style.pointerEvents = 'auto';
    }, 1500);
  }

  // Duel timer
  function startDuelTimer() {
    duelStartTime = Date.now();
    duelTimerDisplay.textContent = '0.0';
    if (duelTimerInterval) clearInterval(duelTimerInterval);
    duelTimerInterval = setInterval(() => {
      let elapsed = (Date.now() - duelStartTime) / 1000;
      duelTimerDisplay.textContent = formatTime(elapsed);
    }, 100);
  }
  function stopDuelTimer() {
    if (duelTimerInterval) clearInterval(duelTimerInterval);
  }

  function endDuelGame(won) {
    stopDuelTimer();
    duelGameActive = false;
    duelResultDisplay.textContent = won ? 'You Won the Duel! +20 coins' : 'You Lost the Duel.';
    if (won) {
      currentUser.coins += 20;
      currentUser.wins++;
      saveUserData(currentUser);
      winsCountDisplay.textContent = currentUser.wins;
      coinsCountDisplay.textContent = currentUser.coins;
      updateLeaderboard();
    }
    // After delay, return to duel queue waiting
    setTimeout(() => {
      duelResultDisplay.textContent = '';
      duelWaitingMsg.style.display = 'block';
      duelGameDiv.style.display = 'none';
      // Put user back in duel queue automatically for demo
      duelQueue = [];
      startDuelQueue();
    }, 4000);
  }


  // ====== INITIALIZE ======
  updateLeaderboard();

})()
</script>

</body>
</html>
